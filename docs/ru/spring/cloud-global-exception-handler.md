## Введение

В микросервисной архитектуре API Gateway служит единой точкой входа для всех клиентских запросов. Эффективная обработка ошибок и мониторинг являются критически важными для обеспечения стабильности системы. Используя глобальные фильтры в Spring Cloud Gateway, можно перехватывать исключения, формировать структурированные ответы об ошибках и интегрироваться с системами мониторинга.

## Глобальные фильтры в Spring Cloud Gateway

### Что такое глобальные фильтры

Глобальные фильтры в Spring Cloud Gateway позволяют модифицировать запросы и ответы на уровне всей системы. Они делятся на три типа:

- **Pre-filters**: Выполняются до отправки запроса к downstream-сервису.
- **Post-filters**: Выполняются после получения ответа от downstream-сервиса.
- **Error-filters**: Выполняются при возникновении ошибок в процессе обработки запроса.

Глобальные фильтры применяются ко всем маршрутам API Gateway, в отличие от маршрутных фильтров, которые действуют только на определенные маршруты.

### Создание глобального фильтра для обработки исключений

Для обработки исключений на уровне API Gateway необходимо создать глобальный фильтр, который будет перехватывать ошибки и формировать структурированный ответ для клиента. Также целесообразно интегрировать механизм логирования ошибок для последующего анализа.

#### Шаги:

1. Создайте класс, реализующий интерфейсы `GlobalFilter` и `Ordered`.
2. Реализуйте логику перехвата исключений и формирования ответа.
3. Зарегистрируйте фильтр как компонент Spring.

## Структурированные ответы об ошибках

### Создание модели структурированного ответа

Структурированный ответ об ошибке помогает клиенту понять суть проблемы. Обычно такие ответы включают:

- **timestamp**: Метка времени ошибки.
- **status**: HTTP-статус код.
- **error**: Краткое описание ошибки.
- **message**: Подробное сообщение об ошибке.
- **path**: Путь запроса, вызвавший ошибку.

Пример структурированного ответа:

```json
{
  "timestamp": "2023-04-27T12:34:56.789+00:00",
  "status": 500,
  "error": "Internal Server Error",
  "message": "Описание ошибки",
  "path": "/api/example"
}
```

### Модификация глобального фильтра для формирования структурированных ошибок

Для формирования структурированных ответов об ошибках необходимо модифицировать глобальный фильтр, добавив логику генерации таких ответов при возникновении исключений.

## Интеграция с системой мониторинга

### Выбор системы мониторинга

Для мониторинга ошибок можно использовать различные системы, такие как Prometheus и Grafana, которые позволяют отслеживать метрики и визуализировать данные.

### Интеграция с Prometheus и Grafana с использованием Micrometer

Micrometer предоставляет возможность интеграции с различными системами мониторинга. Для этого необходимо добавить соответствующие зависимости в проект и настроить конфигурацию.

### Отправка ошибок в систему мониторинга

Ошибки могут быть отправлены в систему мониторинга через метрики, что позволит отслеживать их количество и типы в реальном времени.

## Пример реализации

### Зависимости Maven

Для реализации необходимо добавить следующие зависимости в файл `pom.xml`:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

### Код глобального фильтра

Пример кода глобального фильтра для обработки исключений:

```java
@Component
public class GlobalExceptionFilter implements GlobalFilter, Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return chain.filter(exchange).onErrorResume(ex -> {
            // Логика обработки исключений
            return createErrorResponse(exchange, ex);
        });
    }

    private Mono<Void> createErrorResponse(ServerWebExchange exchange, Throwable ex) {
        // Формирование структурированного ответа
        return exchange.getResponse().writeWith(Mono.just(...));
    }

    @Override
    public int getOrder() {
        return -1; // Устанавливаем порядок выполнения
    }
}
```

### Модель ошибки

Создайте класс для представления структуры ошибки:

```java
public class ErrorResponse {
    private String timestamp;
    private int status;
    private String error;
    private String message;
    private String path;

    // Геттеры и сеттеры
}
```

### Конфигурация мониторинга

Настройте Micrometer для интеграции с Prometheus в файле `application.yml`:

```yaml
management:
  endpoints:
    web:
      exposure:
        include: '*'
  metrics:
    export:
      prometheus:
        enabled: true
```

## Тестирование и отладка

Для проверки глобальных фильтров в Spring Cloud Gateway необходимо написать несколько типов тестов, чтобы убедиться в их корректной работе и функциональности. Вот основные тесты, которые стоит реализовать:

### 1. Тесты на корректность обработки запросов

- **Позитивные тесты**: Убедитесь, что фильтры корректно обрабатывают валидные запросы. Например, проверьте, что заголовки добавляются или изменяются правильно.
- **Негативные тесты**: Проверьте, как фильтры обрабатывают некорректные или неполные запросы. Убедитесь, что система возвращает ожидаемые ошибки.

### 2. Тесты на обработку исключений

- **Тестирование ошибок**: Напишите тесты, которые вызывают исключения в процессе обработки запроса и проверяют, что глобальный фильтр возвращает корректный структурированный ответ об ошибке.
- **Логирование ошибок**: Убедитесь, что все ошибки логируются корректно и информация о них доступна для анализа.

### 3. Тесты на производительность

- **Нагрузочные тесты**: Проведите нагрузочные тесты для оценки производительности фильтров под высокой нагрузкой. Это поможет выявить узкие места в обработке запросов.

### 4. Интеграционные тесты

- **Тестирование взаимодействия с другими сервисами**: Проверьте, как фильтры взаимодействуют с downstream-сервисами. Убедитесь, что запросы правильно маршрутизируются и обрабатываются.

### 5. Тесты на конфигурацию

- **Проверка конфигурации фильтров**: Убедитесь, что фильтры правильно применяются в зависимости от конфигурации маршрутов и условий.

### Пример реализации теста

Для написания тестов можно использовать JUnit и Spring Boot Test. Вот пример простого интеграционного теста:

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
public class GlobalFilterTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testValidRequest() throws Exception {
        mockMvc.perform(get("/api/valid-endpoint"))
               .andExpect(status().isOk())
               .andExpect(header().string("Custom-Header", "ExpectedValue"));
    }

    @Test
    public void testInvalidRequest() throws Exception {
        mockMvc.perform(get("/api/invalid-endpoint"))
               .andExpect(status().isBadRequest())
               .andExpect(jsonPath("$.error").value("Invalid Request"));
    }
}
```

Эти тесты помогут убедиться в корректной работе глобальных фильтров и их способности обрабатывать различные сценарии запросов.

## Дополнительные рекомендации

Рекомендуется использовать централизованное логирование для упрощения анализа ошибок и их последующего устранения.

## Заключение

Использование глобальных фильтров в Spring Cloud Gateway позволяет эффективно обрабатывать исключения, формировать структурированные ответы об ошибках и интегрироваться с системами мониторинга. Это значительно улучшает стабильность и надежность микросервисной архитектуры.